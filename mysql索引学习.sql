1、如果使用ORM 是否需要继续关心索引？
   无论多么复杂的ORM工具，在精妙和复杂的索引面前都是浮云。
   
2、B-Tree索引(mysql讨论索引时默认的类型) 
             (InnoDB使用的B+Tree) 
             通常意味着所有的值都是按顺序存储的。
			 存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。
			 索引对多个值进行排序的依据是create table语句中定义索引时列的顺序。
			 eg： CREATE TABLE `async_message` (
				  `hotel_group_id` bigint(16) NOT NULL,
				  `hotel_id` bigint(16) NOT NULL,
				  `id` bigint(16) NOT NULL AUTO_INCREMENT,
				  `from_Client` varchar(50) DEFAULT NULL,
				  `to_Client` varchar(200) DEFAULT NULL,
				  `header` varchar(50) DEFAULT NULL,
				  `body` varchar(1024) DEFAULT NULL,
				  `timestamp` bigint(16) DEFAULT NULL,
				  `time_to_live` bigint(16) DEFAULT NULL,
				  PRIMARY KEY (`id`),
				  KEY `NewIndex1` (`hotel_group_id`,`hotel_id`,`timestamp`),
				  KEY `index_hhht` (`hotel_group_id`,`hotel_id`,`header`,`timestamp`)
				) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='消息机制';
			 B-Tree索引的查询类型：
			                     1、全值匹配
								 2、匹配最左前缀
								 3、匹配列前缀：可以匹配某一列值的开头部分
								 4、匹配范围值
								 5、精确匹配某一列并范围匹配另一列(eg： 第一列全匹配，第二列范围匹配)
								 6、只访问索引的查询
			 另:因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的order by 操作。
			 限制:
			      1、如果不是按照索引的最左列开始查找则无法使用索引。eg: select *** from async_message where hotel_id = ? and timestamp=? 则无法利用当前索引。
				  2、不能跳过索引中的列.eg：  select *** from async_message where hotel_group_id = ? and timestamp=? *** 这时则只能利用索引的第一列。
				  3、如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找
				     eg:key(a,b,c)
					 select * from  t where a='XXX' and b like '%**%' and c = '' 这时 只能利用索引的前两列
3、哈希索引：
            memory引擎显式支持，只存储对应的哈希值，索引结构十分紧凑。
			限制：
			     1、只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
				 2、并不是按照索引值的顺序存储的，所以也就无法用于排序。
				 3、不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。
				    eg：key(a,b)建立的哈希索引，查询的只有数据列a时，则无法使用。
				 4、哈希索引只支持等值比较查询，= 、 IN()、 <=>(<>不同<=>),也不支持任何范围查询。 eg： where a>180 
				 5、访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值 却有相同的哈希值）。
				 6、如果哈希冲突很多，一些索引的维护操作代价也会很高。
				 
				 
4、空间数据索引（R-Tree）
				 MyISAM表支持空间索引，可以用作地理数据存储。这类索引无须前缀查询，空间索引会引用所有维度来索引数据。
5、全文索引
                它查找的是文本中的关键词，而不是直接比较索引中的值。其和其他的索引匹配方式完全不一样，
				它有许多需要注意的细节，如停用词、词干、复数、布尔搜索等，类似于搜索引擎做的事情，而不是简单的where条件匹配。
				(感兴趣更多的信息可以自查)
				
				
6、索引的优点：
              1、大大减少服务器需要扫描的数据量。
			  2、帮助服务器避免排序和临时表
			  3、可以将随机I/O变为顺序I/O
			  另:对于特大型的表，建立和使用索引的代价将随之增高。这种情况下需要一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录的匹配。
			  分区技术：
			  如果执行那些需要聚合多个应用、分布在多个表的数据查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。
			  
7、高性能索引策略
            1、独立的列：指索引列不能是表达式的一部分，也不能是函数的参数。
			 eg：select *** where TO_DAYS(**) - TO_DAYS(**) <= 10 ;
                 SELECT *** WHERE ACTOR_ID+1 = 5 ;
				 养成简化where条件的习惯，始终将索引列单独放在比较符号的一侧。
            2、前缀索引和索引的选择性：
			   有时候需要索引很长的字符列，这会让索引变得大且慢，一个策略是模拟哈希索引，另外就是可以使用前缀索引。		   
               对于BLOB、TEXT、varchar(很长)  必须使用前缀索引 ，因为mysql不允许索引这些列的完整长度
               eg ： KEY(LEFT(CITY,7))
               对于前缀长度到底是几：计算完整列的选择性，并使用前缀的选择性接近于完整列的选择性。(具体算法可以自己搜)
            3、多列索引(自动的 索引合并策略（了解 自己搜索）)
               常见错误：为每个列创建独立的索引 或者按照错误的顺序创建多列索引。
                         eg: create table t(
						                  c1 int,
										  c2 int,
										  c3 int,
										  KEY(c1),
										  KEY(c2),
										  KEY(c3));			   
               当出现索引合并策略有时候是一种优化的结果，但实际想更多额时候说明了表上额索引建立的很糟糕。
               explain 中看到索引合并，应该好好检查一下查询和表的结构。
         ***4、选择合适的索引列顺序
               至关重要：
			           在一个多列索引中，索引的列的顺序意味着索引首先按照最左列进行排序，其实是第二列，等等。所以索引可以按照升序或者降序进行扫描，
			           以满足精确符号列顺序的order by、group by 和distinct等子句的查询需求。
               列序经验:将选择性最高的列放到索引的最前列（不需要考虑排序和分组的时候）
               where子句中的排序、分组和范围等也是影响因素。

8、冗余和重复索引：
            1、mysql的唯一限制和主键限制都是通过索引实现的。
               KEY(A,B)已存在，再创建KEY(A)(此时 这个索引就是冗余索引)
			   KEY(B) KEY(B,A) 这两者则不是KEY(A,B)的冗余索引。
             通过分析工具PeroconaToolkit	
			2、如果表T 字段ID为主键，有索引KEY(A) 
			   where A=5 order by ID 此时索引会有作用,因为索引KEY(A)相当于在(A,ID)上的索引。
			   如果索引被扩展为KEY(A,B) 
			   where A=5 order by ID 此时就不能索引排序，只能文件排序，其实实际上是索引 A,B,ID
			  
一个问题:
         如果一个表的访问情况是 A B C 三个字段的组合 where A B ,WHERE A C WHERE B C 的访问频率接近，
		 请问此时如何给这个表建立索引呢？
		
9、索引和锁
             InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少Innodb访问的行数。
             select ...  from t where  id<5 and id <> 1 for update.
             结果返回234，但是 			 实际是获取了1-4之间行的排它锁。会锁住第1行。
			 explain: using where ,using index
			 表示mysql服务器将存储引擎返回行以后再应用where过滤条件。
			 此时打开第二个连接 执行 select ... from t where id = 1 for update 会被挂起，直到上面的查询事物释放第一行的锁。
			 表示 使用了索引，innoDB 也可能锁住一些不需要的数据。
			 如果不使用索引查找和锁定行的话，可能会更糟，mysql会做全表扫描并锁住所有的行，而不管是不是需要。
			 
始终记住三个原则:
       1、单行访问是很慢的。特别是在机械硬盘存储中，如果服务器从存储中读取一个数据块只是为了获取其中一行那么就浪费了很多工作。
	      最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率。
       2、按顺序访问范围数据是很快的。第一 顺序I/O不需要多次磁盘寻道，所以比随机I/O要快很多(特别是对机械硬盘)	。第二 如果服务器能够按需要顺序读取数据，
          那么就不需要额外的排序操作，并且group by 查询也无须再做排序 和 将行按组进行聚合计算了。
       3、索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问。		
理解索引是如何工作的非常重要，应该根据这些理解来创建最合适的索引，
而不是根据一些诸如"在所列索引中将选择性最高的列放在第一列"或"应该为where子句中出现的所有列创建索引"之类的经验法则及其推论。
		