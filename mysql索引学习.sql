1、如果使用ORM 是否需要继续关心索引？
   无论多么复杂的ORM工具，在精妙和复杂的索引面前都是浮云。
2、B-Tree  索引  
             通常意味着所有的值都是按顺序存储的。
			 ：存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。
			 索引对多个值进行排序的依据是create table语句中定义索引时列的顺序。
			 key(last_name,fist_name,dob)
			 B-Tree索引的查询类型：
			                     1、全值匹配
								 2、匹配最左前缀
								 3、匹配列前缀：可以匹配某一列值的开头部分
								 4、匹配范围值
								 5、精确匹配某一列冰范围匹配另一列  ：eg 第一列全匹配，第二列范围匹配
								 6、只访问索引的查询
			 限制:
			      1、如果不是按照索引的最左列开始查找则无法使用索引。
				  2、不能跳过索引中的列
				  3、如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找
				     key(a,b,c)
					 select * from  t where a='XXX' and b like '%**%' and c = ''
3、哈希索引：
            memory引擎显式支持，只存储对应的哈希值，索引结构十分紧凑。
			限制：
			     1、只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
				 2、并不是按照索引值的顺序存储的，所以也就无法用于排序。
				 3、不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。
				    eg：key(a,b)建立的哈希索引，查询的只有数据列a时，则无法使用。
				 4、哈希索引只支持等值比较查询，= in() <=>(<>不同<=>),也不支持任何范围查询。 eg where a>180 
				 5、访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值 却有相同的哈希值）。
				 6、如果哈希冲突很多，一些索引的维护操作代价也会很高。
				 
				 
4、空间数据索引（R-Tree）
				 MyISAM表支持空间索引，可以用作地理数据存储。
5、全文索引
                停用词、词干、复数、布尔搜索等，类似于搜索引擎做的事情，而不是简单的where条件匹配。
				
				
				
6、索引的优点：
              1、大大减少服务器需要扫描的数据量。
			  2、帮助服务器避免排序和临时表
			  3、可以将随机IO变为顺序IO
			  另:对于特大型的表，建立和使用索引的代价将随之增高。这种情况下需要一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录的匹配。
			  分区技术：执行需要聚合多个已不够用分布在多个表的数据查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据。
			  
7、高性能索引策略
            1、独立的列：指索引列不能是表达式的一部分，也不能是函数的参数：
			 eg：select *** where TO_DAYS(**) - TO_DAYS(**) <= 10 ;
                 SELECT *** WHERE ACTOR_ID+1 = 5 ;
            2、前缀索引和索引的选择性：
               对于BLOB、TEXT、varchar(很长)  必须使用前缀索引 ，因为mysql不允许索引这些列的完整长度
               eg ： KEY(LEFT(CITY,7))
               对于前缀长度到底是几：计算完整列的选择性，并使用前缀的选择性接近于完整列的选择性。(具体算法可以自己搜)
            3、多列索引(自动的 索引合并策略（了解 自己搜索）)			
               当出现索引合并策略有时候是一种优化的结果，但实际想更多额时候说明了表上额索引建立的很糟糕。
               explain 中看到索引合并，应该好好检查一下查询和表的结构。
         ***4、选择合适的索引列顺序
               至关重要：
                        将选择性最高的列放到索引的最前列（不需要考虑排序和分组的时候）
                where子句中的排序、分组和范围等影响因素。

8、冗余和重复索引：
            1、mysql的唯一限制和主键限制都是通过索引实现的。
               key(A,B)  KEY(A)   KEY(B) KEY(B,A) 四者的关系
             通过分析工具PeroconaToolkit	
9、索引和锁
             InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少innodb访问的行数。
             select ...  from t where  id<5 and id <> 1 for update.
             结果返回234，但是 			 实际是获取了1-4之间行的排它锁。会锁住第1行。
			 explain: using where ,using index
			 表示mysql服务器将存储引擎返回行以后再应用where过滤条件。
			 此时事物 select ... from t where id = 1 for update 会被挂起。
			 ：表示 使用了索引，innoDB 也可能锁住一些不需要的数据。
			 如果不使用索引查找和锁定行的话，可能会更糟，mysql会做全表扫描并锁住所有的行，而不管是不是需要。
		